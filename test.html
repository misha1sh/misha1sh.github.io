<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

        <title>kek</title>
    </head>

    <body>
        <select size="2" id="chooseShowType">
            <option selected value="JSON">JSON</option>
            <option value="TOKENS">TOKENS</option>
        </select>
        <table>
            <tr>
                <td style="width:50%;vertical-align: top;">
                    <textarea id="inp" cols="130" rows="100"></textarea>
                </td>
                <td style="width:100%; vertical-align: top;">
                    <pre id="out">text</pre>
                </td>
            </tr>

          </table>

<style>
    pre {outline: 1px solid #ccc; padding: 5px; margin: 5px; }
.string { color: green; }
.number { color: darkorange; }
.boolean { color: blue; }
.null { color: magenta; }
.key { color: red; }

</style>

<script>
// 11:30


const testText = `
header=
	description=
		Это пример диалога

	person=
		name=  Кот
		color= 1
		side=  left
		aka=   к, кот, котэ, 1

	персонаж=
		имя=     Алиса
		сторона= п
		ака=     алиса, а, 2

part=
	partname= Начало
	page=
		автор=
		Завидев Алису, Кот только улыбнулся.
		Вид у него был добродушный, но когти длинные,
		а зубов так много, что Алиса сразу поняла,
		что с ним шутки плохи.
		алиса=
		Котик! Чешик!
		автор=
		робко начала Алиса.
		Она не знала, понравится ли ему это имя,
		но он только шире улыбнулся в ответ.
		автор=
		Ничего, - подумала Алиса, – кажется, доволен. Вслух же она спросила:
		алиса=
		Скажите, пожалуйста, куда мне отсюда идти?
		кот=
		А куда ты хочешь попасть?
		автор=
		Ответил кот
	page=
		алиса=
		Мне все равно…
		котэ=
		Тогда все равно, куда и идти
		алиса=
		… только бы попасть куда-нибудь
part=
	partname= Середина
	path= res/mid_part.txt
`


const tokenTypes = {
    STRING: "STRING_TOKEN",
    INT: "INT_TOKEN",
    BOOL: "BOOL_TOKEN",
    STRING_ARRAY: "STRING_ARRAY_TOKEN",
    OBJECT: "OBJECT_TOKEN"
}

function splitByTokens(text) {
    let res = [];

    let beforeLastEq = null;
    let betweenLastEqAndNewLine = "";
    let wasNewLine = true;
    let cur = "";

    function processNewLine() {
        if (betweenLastEqAndNewLine != "") {
            betweenLastEqAndNewLine = betweenLastEqAndNewLine + "\n" + cur;
        } else {
            betweenLastEqAndNewLine = cur;
        }
        wasNewLine = true;
        cur = "";
    }

    function processEq() {
        if (beforeLastEq != null) {
            res.push([
                beforeLastEq,
                betweenLastEqAndNewLine.replaceAll(/\t+/g, "").replaceAll("\\=", "=").replaceAll("\\\\", "\\").trim()
            ]);
        } else if (betweenLastEqAndNewLine != "") {
            throw "Got '" + betweenLastEqAndNewLine + "' before first token."
        }

        beforeLastEq = cur.trim();
        wasNewLine = false;
        betweenLastEqAndNewLine = "";
        cur = "";
    }

    for (let i = 0; i < text.length; i++) {
        if (text[i] == "\n") {
            processNewLine();
        } else if (text[i] == "=" && wasNewLine && (i == 0 || text[i - 1] != "\\")) {
            processEq();
        } else {
            cur += text[i];
        }
    }

    if (cur != "") {
        processNewLine();
    }
    if (beforeLastEq != "") {
        processEq();
    }

    return res;
}

var filterInt = function (value) {
  if (/^(\-|\+)?([0-9]+)$/.test(value))
    return Number(value);
  return NaN;
}


function parseTokenTree(tokenTree, tokens, textPos, failedTokensForI) {
    let res = {};
    let i = textPos;
    for (; i < tokens.length; i++) {
        let token = tokens[i][0]
        let fieldValue = tokens[i][1];

        if (!(i in failedTokensForI)) {
            failedTokensForI[i] = [];
        }
        let found = false;
        for (const [key, value] of Object.entries(tokenTree)) {
            if (key == token ||
                !Array.isArray(value.aka) && value.aka == token ||
                Array.isArray(value.aka) && value.aka.includes(token)) {
                    console.log("found", i, token, fieldValue, failedTokensForI);


                let resValue = null;
                if (value.type == tokenTypes.OBJECT) {
                    if (fieldValue != "") {
                        throw "After " + key + " expect another keys, not value " + fieldValue;
                    }
                    [resValue, i] = parseTokenTree(value.fields, tokens, i + 1, failedTokensForI);
                } else if (value.type == tokenTypes.STRING) {
                    resValue = fieldValue;
                } else if (value.type == tokenTypes.INT) {
                    resValue = filterInt(fieldValue);
                    if (isNaN(resValue)) {
                        throw "Illegal number format " + fieldValue;
                    }
                } else if (value.type == tokenTypes.STRING_ARRAY) {
                    resValue = fieldValue.split(",").map(s => s.trim());
                } else if (value.type == tokenTypes.BOOL) {
                    if (fieldValue == "true" || fieldValue == "да") {
                        resValue = true;
                    } else if (fieldValue == "false" || fieldValue == "нет") {
                        resValue = false;
                    } else {
                        throw "Illegal bool format: '" + fieldValue +"'. expected one of 'true' 'false' 'да' 'нет'";
                    }
                }

                if ('isArray' in value && value.isArray === true) {
                    let keyToPut = key;
                    let valueToPut = resValue;
                    if ('putToArray' in value) {
                        keyToPut = value['putToArray'];
                        valueToPut = {
                            "key": key,
                            "value": resValue
                        }
                    }
                    if (!res.hasOwnProperty(keyToPut)) {
                        res[keyToPut] = [];
                    }
                    res[keyToPut].push(valueToPut);

                } else if (key in res) {
                    console.log(value);
                    throw "Found more than one field with key " + key;
                } else {
                    res[key] = resValue;
                }
                console.log(key, resValue, res);

                found = true;
                break;
            } else {
                failedTokensForI[i].push(key);
                if (Array.isArray(value.aka)) {
                    failedTokensForI[i] = failedTokensForI[i].concat(value.aka);
                } else {
                    failedTokensForI[i].push(value.aka);
                }
            }
        }
        if (!found) {
            console.log("failed", i, token, fieldValue, failedTokensForI);
            break;
        }
    }

    return [res, i - 1];
}



function vanyaToJson(text) {

    const headerTokenTree = {
        "header": {
            type: tokenTypes.OBJECT,
            aka: "легенда",
            fields: {
                "title": {
                    type: tokenTypes.STRING,
                    aka: "название"
                },
                "shownm": {
                    type: tokenTypes.BOOL,
                    aka: ["shownames", "showname"]
                },
                "description": {
                    type: tokenTypes.STRING,
                    aka: "описание"
                },
                "person": {
                    type: tokenTypes.OBJECT,
                    isArray: true,
                    aka: "персонаж",
                    fields: {
                        "name" : {
                            type: tokenTypes.STRING,
                            aka: "имя"
                        },
                        "color" : {
                            type: tokenTypes.INT,
                            aka: "цвет"
                        },
                        "side": {
                            type: tokenTypes.STRING,
                            aka: "сторона"
                        },
                        "aka": {
                            type: tokenTypes.STRING_ARRAY,
                            aka: "ака"
                        }
                    }
                }
            }
        }
    }

    const tokens = splitByTokens(text);
    let failedTokensForI = {};
    const [header, headerEnd] = parseTokenTree(headerTokenTree, tokens, 0, failedTokensForI);

    // validateHeader(header);

    let pageFieldsTree = {
        '0': {
            type: tokenTypes.STRING,
            isArray: true,
            putToArray: "messages",
            aka: ['author', 'автор']
        }
    };

    if ("header" in header && "person" in header["header"]) {
        for (let person of header["header"]["person"]) {
            if ("name" in person) {
                pageFieldsTree[person["name"]] = {
                    type: tokenTypes.STRING,
                    isArray: true,
                    putToArray: "messages",
                    aka: person.aka || [],
                }
            }
        }
    }

    const bodyTokenTree = {
        "part": {
            type: tokenTypes.OBJECT,
            isArray: true,
            aka: "глава",
            fields: {
                "partname": {
                    type: tokenTypes.STRING,
                    aka: "название"
                },
                "page": {
                    type: tokenTypes.OBJECT,
                    isArray: true,
                    aka: ["страница", "стр"],
                    fields: pageFieldsTree,
                },
                "path": {
                    type: tokenTypes.STRING,
                    aka: "путь"
                }

            }
        }
    }

    const [body, lastToken] = parseTokenTree(bodyTokenTree, tokens, headerEnd + 1, failedTokensForI);

    if (lastToken != tokens.length - 1) {
        throw "Token for " + tokens[lastToken + 1] + " not found. Expected one of " + JSON.stringify(failedTokensForI[lastToken + 1]);
    }

    return [header["header"], body];
}
function syntaxHighlight(json) {
    if (typeof json != 'string') {
         json = JSON.stringify(json, undefined, 2);
    }
    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
        var cls = 'number';
        if (/^"/.test(match)) {
            if (/:$/.test(match)) {
                cls = 'key';
            } else {
                cls = 'string';
            }
        } else if (/true|false/.test(match)) {
            cls = 'boolean';
        } else if (/null/.test(match)) {
            cls = 'null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
    });
}


window.addEventListener("load", function() {
    const inputTextElement = document.getElementById("inp");
    const outputTextElement = document.getElementById("out");

    const chooseShowType = document.getElementById("chooseShowType");
    function handler() {
        if (chooseShowType.value == "JSON") {
            try {
                const [header, body] = vanyaToJson(inputTextElement.value);
                outputTextElement.innerHTML = syntaxHighlight(JSON.stringify(header, null, '  ')) + "<br><br>" +
                syntaxHighlight(JSON.stringify(body, null, '  '));
            } catch (ex) {
                outputTextElement.innerHTML = ex;
            }
        } else if (chooseShowType.value == "TOKENS") {
             outputTextElement.innerHTML = syntaxHighlight(JSON.stringify(splitByTokens(inputTextElement.value), null, '  '))
        }
    }

    inputTextElement.onkeyup = handler;
    chooseShowType.onchange = handler;
    handler();
    inputTextElement.value = testText;


    console.log(inputTextElement);
});
/*
document.write(JSON.stringify(splitByTokens(testText)));
document.write("<br><br>");
const [header, body] = vanyaToJson(testText);
document.write(JSON.stringify(header));
document.write("<br><br>");
document.write(JSON.stringify(body));*/
</script>

</body>
</html>